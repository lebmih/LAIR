#### Alternative exon usage.
#### This script maps the J-C insertion to the human IG or TCR loci to profile
#### the alternative exon usage. Used in Figure 6.

# Working folder ----------------------------------------------------------
setwd("C:/Users/User/Documents/Lab/LongBCRs/bioinformatics/lair")


# Libraries ---------------------------------------------------------------
library(stringr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(seqinr)
library(stringi)
library(DescTools)


# Functions ---------------------------------------------------------------
# This function aids the search for the particular sequence via text search,
# creating a library of regular expressions matching to the patter with
# specified number of mutations.
create.mutants.lib <- function(sequence, mut.n = 1, if.collapse = TRUE){
  mut.lib <- c()
  for (i in seq(str_length(sequence))) {
    sequence.tmp <- sequence
    substr(sequence.tmp, i, i) <- "."
    mut.lib <- c(mut.lib, sequence.tmp)
  }
  if(if.collapse == TRUE) {
    mut.lib <- str_c(mut.lib, collapse = "|")
  }
  return(mut.lib)
}
# This function is similar to the previous one but allows for indels.
create.mutants.lib.indel <- function(sequence, mut.n = 1, if.collapse = TRUE){
  mut.lib <- c()
  for (i in seq(str_length(sequence))) {
    sequence.tmp <- paste0(substr(sequence,0,i-1), ".{0,2}",
                           substr(sequence,i+1, str_length(sequence)))
    mut.lib <- c(mut.lib, sequence.tmp)
  }
  if(if.collapse == TRUE) {
    mut.lib <- str_c(mut.lib, collapse = "|")
  }
  return(mut.lib)
}
# A simple reverse-complement transformation.
rc <- function(string) {
  string <- stri_reverse(string)
  string <- unlist(base::strsplit(string, ""))
  a <- which(string == "A")
  t <- which(string == "T")
  c <- which(string == "C")
  g <- which(string == "G")
  string[a] <- "T"
  string[t] <- "A"
  string[c] <- "G"
  string[g] <- "C"
  string <- stri_flatten(string)
  return(string)
}

# Primers and genes for IGH -----------------------------------------------
# Importing the primers used for IGH profiling. Change the primers according to
# the locus. Primers used in the study are provided in the table S4.
primers <- read.fasta("igh_primers.fa", as.string = TRUE)

primers <- data.frame(name = names(unlist(primers)),
                      seq = str_to_upper(unlist(primers)),
                      row.names = NULL,
                      stringsAsFactors = FALSE)
# Constant gene fragments upstream to the primer binding sites (from GRCh38 IGH
# locus).
constants <- str_to_upper(c("ggagtgcatccgcc",
                            "cctccaccaagggc",
                            "cttccaccaagggc",
                            "catccccgaccagccc",
                            "cctccacacagagc"))
names(constants) <- c("IGHM", "IGHG1/2", "IGHG3/4", "IGHA1/2", "IGHE")
# Subsetting the constant genes primers from the imported list.
c.primer <- primers$seq[primers$name %in% c("CHM", "CHA", "CHG")]
names(c.primer) <- c("CHM", "CHA", "CHG")
c.primer.rc <- c()
for (i in c.primer) {
  c.primer.rc <- c(c.primer.rc, rc(i))
}
names(c.primer.rc) <- c("CHM", "CHA", "CHG")
# V primers used for IGH profiling.
v.primer <- primers$seq[!primers$name %in% c("CHM", "CHA", "CHG")]
v.primer.rc <- c()
for (i in v.primer) {
  v.primer.rc <- c(v.primer.rc, rc(i))
}
names(v.primer) <- primers$name[!primers$name %in% c("CHM", "CHA", "CHG")]
names(v.primer.rc) <- primers$name[!primers$name %in% c("CHM", "CHA", "CHG")]

# Import files ------------------------------------------------------------
# The fasta files were generated by:
# 1) pairing the fastq reads by PEAR software;
# 2) translating it to fasta with sed command.
files <- list.files("igh_run9/", pattern = ".fasta", full.names = TRUE)

# Merging the reads from different files into a single dataframe via a loop.
reads <- data.frame()
for (i in files) {
  reads.fa <- read.fasta(i, as.string = TRUE)
  filename <- unlist(str_split(i, pattern = "/"))[2]
  filename <- unlist(str_split(filename, pattern = "\\."))[1]
  filename <- unlist(str_split(filename, pattern = "_"))[2]
  reads.tmp <- data.frame(read.id = names(unlist(reads.fa)),
                          seq = str_to_upper(unlist(reads.fa)),
                          sample = filename,
                          row.names = NULL,
                          stringsAsFactors = FALSE)
  reads <- reads %>% bind_rows(reads.tmp)
  print(i)
}
rm(reads.fa, reads.tmp, i, filename)

# Detecting the V primer --------------------------------------------------
# Detecting the primer in the first 50 nt of the merged reads.
coi <- str_sub(reads$seq, 1, 50)
reads$v.primer <- NA
reads$v.primer.start <- NA
reads$v.primer.end <- NA
# First round - detecting the primer by a simple text search.
for (i in seq(length(v.primer))) {
  primer.search <- unlist(str_locate(coi, v.primer[i]))
  whch <- !is.na(primer.search[,"start"])
  reads$v.primer[whch] <- names(v.primer[i])
  reads$v.primer.start[whch] <- primer.search[whch,"start"]
  reads$v.primer.end[whch] <- primer.search[whch,"end"]
  print(v.primer[i])
}
rm(primer.search, i)
# V primer was found in
sum(!is.na(reads$v.primer)) # During the first round.

# Second round - looking for a primer allowing for one mutation.
reads.nov <- reads %>% filter(is.na(v.primer))
coi <- str_sub(reads.nov$seq, 1, 50)
for (i in seq(length(v.primer))) {
  v.primer.i <- create.mutants.lib(v.primer[i])
  primer.search <- unlist(str_locate(coi, v.primer.i))
  whch <- !is.na(primer.search[,"start"])
  reads.nov$v.primer[whch] <- names(v.primer[i])
  reads.nov$v.primer.start[whch] <- primer.search[whch,"start"]
  reads.nov$v.primer.end[whch] <- primer.search[whch,"end"]
  print(v.primer[i])
}
# V primer was found in
sum(!is.na(reads.nov$v.primer)) # During the second round.
# Gluing back the dataframe.
reads <- reads %>% filter(!is.na(v.primer)) %>%
  bind_rows(reads.nov)
# In total V primer was found in
sum(!is.na(reads$v.primer))
# Storing the No-V reads in the separate table.
reads.nov <- reads %>% filter(is.na(v.primer))

# Third round - looking for a primer allowing for one mutation with an indel.
reads.nov <- reads %>% filter(is.na(v.primer))
coi <- str_sub(reads.nov$seq, 1, 50)
for (i in seq(length(v.primer))) {
  v.primer.i <- create.mutants.lib.indel(v.primer[i])
  primer.search <- unlist(str_locate(coi, v.primer.i))
  whch <- !is.na(primer.search[,"start"])
  reads.nov$v.primer[whch] <- names(v.primer[i])
  reads.nov$v.primer.start[whch] <- primer.search[whch,"start"]
  reads.nov$v.primer.end[whch] <- primer.search[whch,"end"]
  print(v.primer[i])
}
# V primer was found in
sum(!is.na(reads.nov$v.primer)) # During the third round.
# Gluing back the dataframe.
reads <- reads %>% filter(!is.na(v.primer)) %>%
  bind_rows(reads.nov)
# In total V primer was found in
sum(!is.na(reads$v.primer))
# Storing the No-V reads in the separate table.
reads.nov <- reads %>% filter(is.na(v.primer))
write.table(reads.nov, "igh_novprimer_DATE.txt", quote = FALSE, sep = "\t",
            row.names = FALSE)
rm(reads.nov)

# Detecting the C primer --------------------------------------------------
# Detecting the constant primer in the last 35 nt of the reads.
coi <- str_sub(reads$seq, -35, -1)
reads$c.primer <- NA
reads$c.primer.start <- NA
reads$c.primer.end <- NA
# First round - detecting the primer by a simple text search.
for (i in seq(length(c.primer.rc))) {
  primer.search <- unlist(str_locate(coi, c.primer.rc[i]))
  whch <- !is.na(primer.search[,"start"])
  reads$c.primer[whch] <- names(c.primer.rc[i])
  reads$c.primer.start[whch] <- primer.search[whch,"start"]
  reads$c.primer.end[whch] <- primer.search[whch,"end"]
  print(names(c.primer.rc[i]))
}
rm(primer.search, i)
# C primer was found in
sum(!is.na(reads$c.primer)) # During the first round.

# Second round - looking for a primer allowing for one mutation.
reads.noc <- reads %>% filter(is.na(c.primer))
coi <- str_sub(reads.noc$seq, -35, -1)
for (i in seq(length(c.primer.rc))) {
  c.primer.i <- create.mutants.lib(c.primer.rc[i])
  primer.search <- unlist(str_locate(coi, c.primer.i))
  whch <- !is.na(primer.search[,"start"])
  reads.noc$c.primer[whch] <- names(c.primer.rc[i])
  reads.noc$c.primer.start[whch] <- primer.search[whch,"start"]
  reads.noc$c.primer.end[whch] <- primer.search[whch,"end"]
  print(names(c.primer.rc[i]))
}
# C primer was found in
sum(!is.na(reads.noc$c.primer)) # During the second round.
# Gluing back the dataframe.
reads <- reads %>% filter(!is.na(c.primer)) %>%
  bind_rows(reads.noc)
# In total C primer was found in
sum(!is.na(reads$c.primer))
# Storing the No-C reads in the separate table.
reads.noc <- reads %>% filter(is.na(c.primer))

# Third round - looking for a primer allowing for one mutation and an indel.
reads.noc <- reads %>% filter(is.na(c.primer))
coi <- str_sub(reads.noc$seq, -35, -1)
for (i in seq(length(c.primer.rc))) {
  c.primer.i <- create.mutants.lib.indel(c.primer.rc[i])
  primer.search <- unlist(str_locate(coi, c.primer.i))
  whch <- !is.na(primer.search[,"start"])
  reads.noc$c.primer[whch] <- names(c.primer.rc[i])
  reads.noc$c.primer.start[whch] <- primer.search[whch,"start"]
  reads.noc$c.primer.end[whch] <- primer.search[whch,"end"]
  print(names(c.primer.rc[i]))
}
# C primer was found in
sum(!is.na(reads.noc$c.primer)) # During the second round.
# Gluing back the dataframe.
reads <- reads %>% filter(!is.na(c.primer)) %>%
  bind_rows(reads.noc)
# In total C primer was found in
sum(!is.na(reads$c.primer))
# Storing the No-C reads in the separate table.
reads.noc <- reads %>% filter(is.na(c.primer))
write.table(reads.noc, "igh_nocprimer_DATE.txt", quote = FALSE, sep = "\t",
            row.names = FALSE)
rm(reads.noc)


# Filtering the V+C+ reads, measuring the length of the reads. ------------
reads <- reads %>%
  filter(!is.na(v.primer) & !is.na(c.primer)) %>%
  mutate(read.len = str_length(seq))
# Calculating the correct C primer coordinates (as the search was performed in a
# substring).
reads <- reads %>%
  mutate(c.primer.start = read.len - 35 + c.primer.start,
         c.primer.end = read.len - 35 + c.primer.end)

rm(primer.search, c.primer, c.primer.i, c.primer.rc, v.primer,
   v.primer.rc, v.primer.i, i, whch, coi)
# Storing the dataframe with the filtered reads.
write.table(reads, "igh_DATE.txt", quote = FALSE, sep = "\t",
            row.names = FALSE)

# Collapsing the reads into clones ----------------------------------------
# The reads are collapsed into unique sequences to make it easier to process
# them further. The information about the reads number assigned to each clone is
# retained and used downstream for the quantification.
# Cropping the reads from V primer end to C primer start.
reads <- reads %>%
  mutate(seq = str_sub(seq, v.primer.end + 1, c.primer.start - 1))

# Collapsing the reads into the clones.
reads <- reads %>% group_by(seq, sample) %>%
  summarise(read.count = n(),
            v.primer = nth(v.primer, 1),
            c.primer = nth(c.primer, 1))
reads$clone.id <- seq(nrow(reads))
reads <- reads %>% ungroup() %>%
  mutate(read.len = str_length(seq))

# Detecting the C gene ----------------------------------------------------
# Detecting the constant gene in the last 40 nt of the reads.
coi <- str_sub(reads$seq, -45, -1)
reads$c.gene <- NA
reads$c.start <- NA
reads$c.end <- NA
# First round - detecting the gene by a simple text search.
for (i in seq(length(constants))) {
  search <- unlist(str_locate(coi, constants[i]))
  whch <- !is.na(search[,"start"])
  reads$c.gene[whch] <- names(constants[i])
  reads$c.start[whch] <- search[whch,"start"]
  reads$c.end[whch] <- search[whch,"end"]
}
rm(search, i)
# C gene was found in
sum(!is.na(reads$c.gene)) # During the first round.

# Second round - detecting a c gene allowing for one mutation.
reads.nocgene <- reads %>% filter(is.na(c.gene))
coi <- str_sub(reads.nocgene$seq, -45, -1)
for (i in seq(length(constants))) {
  const <- create.mutants.lib.indel(constants[i])
  search <- unlist(str_locate(coi, const))
  whch <- !is.na(search[,"start"])
  reads.nocgene$c.gene[whch] <- names(constants[i])
  reads.nocgene$c.start[whch] <- search[whch,"start"]
  reads.nocgene$c.end[whch] <- search[whch,"end"]
}
# C gene was found in
sum(!is.na(reads.nocgene$c.gene)) # During the second round.
# Gluing back the dataframe.
reads <- reads %>% filter(!is.na(c.gene)) %>%
  bind_rows(reads.nocgene)
# In total C gene was found in
sum(!is.na(reads$c.gene))
# Storing the No-C reads in the separate table.
reads.nocgene <- reads %>% filter(is.na(c.gene))

# Third round - 3 mm allowed, hamming-distance based.
reads.nocgene <- reads.nocgene %>% filter(read.len > 14)
coi <- str_sub(reads.nocgene$seq, -14, -1)

for(i in seq(length(coi))){
  dist <- StrDist(coi[i], constants[5], method = "hamming")
  if(dist <= 3){
    reads.nocgene$c.gene[i] <- names(constants[5])
    reads.nocgene$c.start[i] <- 32
    reads.nocgene$c.end[i] <- 45
  }
}
# C gene was found in
sum(!is.na(reads.nocgene$c.gene)) # During the third round.
# Gluing back the dataframe.
reads <- reads %>% filter(!is.na(c.gene)) %>%
  bind_rows(reads.nocgene)
# In total C gene  was found in
sum(!is.na(reads$c.gene))
# Storing the No-C reads in the separate table.
reads.nocgene <- reads %>% filter(is.na(c.gene))

# Removing the clones with no C gene mapped.
reads <- reads %>% filter(!is.na(c.gene))

# Adjusting the C coordinates (as the substring was used).
reads <- reads %>%
  mutate(c.start = read.len - 45 + c.start,
         c.end = read.len - 45 + c.end)

# Storing the No-C reads and the filtered table.
write.table(reads,
            paste0("igh_",
                   format(Sys.time(),"%d%m%y_%H%M"),".txt"),
            sep = "\t", quote = FALSE, row.names = FALSE)
write.table(reads.nocgene,
            paste0("igh_nocgene_",
                   format(Sys.time(),"%d%m%y_%H%M"),".txt"),
            sep = "\t", quote = FALSE, row.names = FALSE)
rm(coi, const, constants, i, dist,files, whch, search, reads.nocgene)
# Summarising the filtering.
reads.sum <- reads %>% group_by(sample) %>%
  summarise(clones = n(),
            reads = sum(read.count))

# IgBLAST -----------------------------------------------------------------
# IgBLAST is performed outside of R, with a command line igblast program.
# Exporting the substring - region of interest - into a text file.
roi <- str_sub(reads$seq, 1, reads$c.start - 1)
write.fasta(as.list(roi),
            as.list(reads$clone.id),
            file.out = paste("start_",
                             format(Sys.time(),"%d%m%y_%H%M"),".fa", sep = ""))
# Performing the blast with IMGT segments as the database, default parameters.
igblast.results <- read.table("igh_DATE.txt",
                              sep = "\t", stringsAsFactors = FALSE,
                              header = TRUE)
igblast.results <- igblast.results %>%
  select(sequence_id, v_call, v_sequence_start,
         v_sequence_end, v_identity, d_call, d_sequence_start, d_sequence_end,
         d_identity, j_call, j_sequence_start,
         j_sequence_end, j_identity, np1_length) %>%
  mutate(clone.id = sequence_id) %>% select(-sequence_id)
# Appending the reads dataframe with the IgBLAST results.
reads <- reads %>% left_join(igblast.results, by = "clone.id")
rm(igblast.results)
reads <- reads %>%
  mutate(v.call = v_call, v.identity = v_identity, j.call = j_call, j.identity = j_identity,
         v.start = v_sequence_start, v.end = v_sequence_end,
         j.start = j_sequence_start, j.end = j_sequence_end,
         d.call = d_call, d.identity = d_identity, d.start = d_sequence_start,
         d.end = d_sequence_end) %>%
  select(-c("v_call", "v_identity", "j_call", "j_identity", "v_sequence_start",
            "v_sequence_end", "j_sequence_start", "j_sequence_end", "np1_length",
            "d_call", "d_identity", "d_sequence_start", "d_sequence_end"))
# Storing the table with IgBLAST results.
write.table(reads, paste0("igh_", format(Sys.time(),"%d%m%y_%H%M"),".txt"),
            sep = "\t", quote = FALSE, row.names = FALSE)
# Printing out the results of IgBLAST.
sum(!is.na(reads$v.identity))
sum(!is.na(reads$j.identity))
reads.sum <- reads %>% group_by(sample) %>%
  summarise(v.found = sum(!is.na(v.identity)),
            d.found = sum(!is.na(d.identity)),
            j.found = sum(!is.na(j.identity)))
# Storing the reads for which the segments were not detected.
reads.no.j <- reads %>% filter(is.na(j.identity))
reads.no.v <- reads %>% filter(is.na(v.identity))
reads.no.d <- reads %>% filter(is.na(d.identity))
reads.no.v$problem <- "NoV"
reads.no.d$problem <- "NoD"
reads.no.j$problem <- "NoJ"
reads.no.seg <- bind_rows(reads.no.v, reads.no.d, reads.no.j)
write.table(reads.no.seg, paste0("igh_naive_run9_nosegment_", format(Sys.time(),"%d%m%y_%H%M"),".txt"),
            sep = "\t",
            quote = FALSE, row.names = FALSE)
rm(reads.no.v, reads.no.d, reads.no.j, reads.no.seg)
# Filtering out the reads with any segment undetermined.
reads <- reads %>% filter(!is.na(v.identity) &
                                    !is.na(d.identity) &
                                    !is.na(j.identity))
# Plotting the length distribution of the filtered reads.
ggplot(reads)+
  geom_histogram(aes(x = c.start - j.end),
                 binwidth = 5, color = "black", fill = "grey")+
  theme_classic()

# BLAST -------------------------------------------------------------------
# BLAST is performed in command line with BLAST+ software.
reads.roi <- reads %>% filter(c.start - j.end > 10)

roi <- str_sub(reads.roi$seq, reads.roi$j.end + 1, reads.roi$c.start - 1)
write.fasta(as.list(roi),
            as.list(reads.roi$clone.id),
            file.out = paste("insert_",
                             format(Sys.time(),"%d%m%y_%H%M"),".fa", sep = ""))
# Using the IGH locus only as the database.
blast.results <- read.table("inserts_DATE.txt", header = FALSE, sep = "\t",
                            stringsAsFactors = FALSE)
colnames(blast.results) <- c("clone.id", "locus.call", "locus.identity",
                             "locus.length", "locus.mm", "locus.gaps",
                             "locus.start", "locus.end", "locus.template.start",
                             "locus.template.end", "locus.evalue",
                             "locus.score")
# Fixing the shift in the coordinates introduced by BLASTing.
reads.1 <- reads.roi %>% left_join(blast.results, by = "clone.id") %>%
  select(-c("locus.mm", "locus.gaps", "locus.evalue")) %>%
  mutate(locus.start = j.end + locus.start,
         locus.end = j.end + locus.end,
         locus.template.start = locus.template.start + 105586437 - 1,
         locus.template.end = locus.template.end + 105586437 - 1)

reads.1 <- reads.1 %>% filter(!is.na(locus.call))
# Storing the table appended with BLAST results.
write.table(reads.1, paste0("igh_onlyIgHmapped_",
                            format(Sys.time(),"%d%m%y_%H%M"),".txt"),
            quote = FALSE,
            sep = "\t", row.names = FALSE)

# Visualising IGH locus ---------------------------------------------------
# Plotting the coordinate of mappings.
ggplot(reads.1)+
  geom_histogram(aes(x = locus.template.start),
                 binwidth = 1000, color = "black", fill = "grey")+
  theme_classic()+
  scale_y_log10()
# Plotting small 4kb windows separately.
starts <- seq(105544000, 106882000, 4000)

# Plot characteristics
plot.prm <- list(width = 2100, height = 900, x.margin = 50,
                 y.margin = 10, thick = 10, trianglewidth = 6,
                 triangleheight = 10)
plot.prm$inner.width <- plot.prm$width - 2*plot.prm$x.margin
plot.prm$inner.height <- plot.prm$height - 2*plot.prm$y.margin
color_of_lines <- 'black'
text.offset <- -30
step.between.inserts <- 15
insert.thickness <- 3
# Plotting each 4kb window (if there are reads mapped to this window).
for(k in seq(length(starts))){
  region_start <- starts[k]
  region_end <- region_start + 4000
  # Introducing the scaling factor.
  plot.prm$bpperpxl <- (region_end - region_start)/plot.prm$inner.width
  # Filtering the mappings falling into the window.
  reads.tmp <- reads.1 %>%
    filter(locus.template.start > region_start & locus.template.end <= region_end)
  if(nrow(reads.tmp) == 0){
    next
  }
  # Calculating the coverage
  step <- 20
  coverage <- c()
  for(i in seq(region_start, region_end, step)){
    coverage.tmp <-
      sum(reads.tmp$read.count[reads.tmp$locus.template.start > i & reads.tmp$locus.template.end <= i])
    coverage <- c(coverage, coverage.tmp)
  }
  if(max(coverage) < 10){
    next
  }
  # Storing the coverage in a dataframe for plotting.
  cvrg <- data.frame(point = seq(region_start, region_end, step),
                     coverage = coverage)
  cvrg <- cvrg %>% mutate(cvrg.lg = log10(coverage+1))
  # Gene coordinates from GeneCards.
  genes <-
    read.table("igh_locus_genes.txt", header = TRUE, sep = "\t",
               stringsAsFactors = FALSE)
  genes <- genes %>% filter((start >= region_start & start <= region_end) |
                              (end >= region_start & end <= region_end) |
                              (start < region_start & end > region_end))
  genes$start[genes$start < region_start] <- region_start
  genes$end[genes$end > region_end] <- region_end
  # Calculating the coordinates for the genes.
  genes <- genes %>%
    mutate(AX = (start - region_start)/plot.prm$bpperpxl + plot.prm$x.margin,
           BX = (end - region_start)/plot.prm$bpperpxl + plot.prm$x.margin,
           AY = plot.prm$height/2 - plot.prm$thick*3,
           BY = plot.prm$height/2 + plot.prm$thick*3)

  scaling_factor <- 50

  cvrg <- cvrg %>% filter(coverage != 0) %>%
    mutate(AX = (point - region_start - (step/2))/
             plot.prm$bpperpxl + plot.prm$x.margin,
           AY = plot.prm$height/2,
           BX = (point - region_start + (step/2))/
             plot.prm$bpperpxl + plot.prm$x.margin,
           BY = AY + scaling_factor*cvrg.lg)
  # Actual plotting.
  locusplot <- ggplot(data = genes)+
    # Canvas
    coord_cartesian(xlim = c(0, plot.prm$width), ylim = c(0, plot.prm$height))+
    # The line representing the DNA
    geom_segment(aes(x = plot.prm$x.margin,
                     y = plot.prm$height/2,
                     xend = plot.prm$width-plot.prm$x.margin,
                     yend = plot.prm$height/2),
                 color = color_of_lines, size = 1, alpha = 0.5)+
    # The 1 kb reference line
    geom_segment(aes(x = plot.prm$x.margin,
                     y = (plot.prm$height/2) + 2*text.offset,
                     xend = plot.prm$x.margin+1000/plot.prm$bpperpxl,
                     yend = (plot.prm$height/2) + 2*text.offset),
                 arrow = arrow(angle = 90, ends = "both",
                               length = unit(5/plot.prm$height, "npc")))+
    # The label for 1 kb reference line.
    geom_text(aes(x = plot.prm$x.margin+500/plot.prm$bpperpxl,
                  y = (plot.prm$height/2) + 2.5*text.offset,
                  label = "1 kb"), size = 4, colour = color_of_lines)+
    # The genes represented as the rectangles.
    geom_rect(aes(xmin = AX, ymin = AY, xmax = BX, ymax = BY),
              color = "black", fill = "grey")+
    geom_text(aes(x = (AX+BX)/2, y = AY-15, label = gene))+
    # The coverage represented as the rectangles.
    geom_rect(data = cvrg, aes(xmin = AX, ymin = AY, xmax = BX, ymax = BY),
              color = "black", fill = "grey")+
    # Reference segment representing 1000000 reads level.
    geom_segment(aes(x = plot.prm$x.margin, y = plot.prm$height/2,
                     xend = plot.prm$x.margin,
                     yend = (plot.prm$height/2) + scaling_factor * 6))+
    scale_fill_manual(values = fill)+
    scale_color_manual(values = fill)+
    theme_void()+
    theme(legend.position = "none")

  locusplot
  plot.name <- paste0("igh_", as.character(region_start),
                      "_", format(Sys.time(),"%d%m%y_%H%M"), ".svg")
  ggsave(filename = plot.name, device = "svg",
         width = 5, height = 6, plot = locusplot)

}

# Pie chart ---------------------------------------------------------------
# In this section it is determined how many reads are mapped to the regions
# between the segments or the genes.
genes <-
  read.table("igh_locus_genes.txt", header = TRUE, sep = "\t",
             stringsAsFactors = FALSE)

genes <- genes %>% mutate(gene = str_remove(gene, "IGH"))
# intersegm dataframe stores the coordinates of the regions between the segments
# and the genes.
intersegm.names <- c()
intersegm.starts <- c()
intersegm.ends <- c()
for(i in seq(nrow(genes)-1)){
  intersegm.names <- c(intersegm.names, str_c(genes$gene[i], genes$gene[i+1], sep = "-"))
  intersegm.starts <- c(intersegm.starts, genes$end[i])
  intersegm.ends <- c(intersegm.ends, genes$end[i+1])
}

intersegm <- data.frame(name = intersegm.names,
                        start = intersegm.starts,
                        end = intersegm.ends)
intersegm$reads <- 0

reads.agg <- reads.1 %>% group_by(clone.id) %>%
  summarise(read.count = nth(read.count, 1),
            locus.template.start = min(locus.template.start),
            locus.template.end = max(locus.template.end))
# Reads mapped to each intersegmental/genic element are counted.
for(i in seq(nrow(intersegm))){
  intersegm$reads[i] <-
    sum(reads.agg$read.count[(reads.agg$locus.template.start <= intersegm$start[i]) &
                               (reads.agg$locus.template.start > intersegm$end[i])])
}
# Only the regions with reads mapped to them are considered.
intersegm <- intersegm %>% filter(reads > 1)
sum(intersegm$reads)

reads.pie <- reads.pie %>%
  mutate(intersegm = factor(intersegm, levels = c("J6-M","J1-J2",
                                                  "J2-J3","J3-J4",
                                                  "J5-J6","Other")))
# Plotting the pie chart representing the proportion of reads mapped to the
# regions.
ggplot(reads.pie)+
  geom_bar(aes(x = 1, y = read.count, fill = intersegm), stat = "identity",
           position = position_stack(reverse = TRUE), color = "black")+
  theme_classic()+
  theme(legend.position = "none", axis.title.x = element_blank(),
        axis.title.y = element_blank(), axis.line.x = element_blank(),
        axis.line.y = element_blank(), axis.text.y = element_blank(),
        axis.ticks.y = element_blank())+
  coord_polar(theta = "y")

ggsave("igh_piechart_DATE.svg", device = "svg", width = 5, height = 5)

################################################### END OF THE SCRIPT ###---